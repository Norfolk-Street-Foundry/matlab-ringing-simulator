% FUNCTION genringing
%  genringing( bellset, rows, outputs, strike_data, peal_time, start_rounds, end_rounds)
%
% bellset is a structure containing the following elements:
%  - bells (1xN structure)
%    - handstroke (cell array of wav data, representing different handstrokes of this bell)
%    - backstroke (... backstrokes)
%  - fs (sampling frequency of the WAV data)
%  - channel (number of channels in the WAV data, typically one or two)
%  - nominal_peal_time (used if no other speed is provided)
%
% rows is a matrix describing the changes to be rung - usually generated by
% rows_from_gsiril
%
% outputs is either a filename or a cell array of filenames describing the output
%  The output format is deduced based on file extension:
%   .wav - Audio output
%   .txt - Lowndes output
%   .xml - The 'Toast' XML data format
%
% start_rounds / end_rounds are the number of rounds starting and ending
% the touch. Defaults to 2 if not specified
%
% peal_time - override the tower nominal peal time
%
% lowndes_output - if true, then output a 'lowndes' format file suitable
% for analysis in CAS etc. Default is true.
%
% strike_data is a structure containing the following elements:
%  - handstroke_gap (in terms inter-bell gap - that is, normally set to 1)
%  - bell (1xN structure)
%   - offset
%    - hand (handstroke offset for this bell)
%    - back (backstroke offset for this bell)
%   - stdev
%    - hand (handstroke deviation for this bell)
%    - back (backstroke deviation for this bell)
%  - error_scale (how are the stdevs interpreted - valid settings are either 'ms' or 'bell')
%  - error_distribution (formation of  - valid settings are either 'ms' or 'bell')
%  - offset_scale (how are the offsets interpreted - valid settings are either 'ms' or 'bell')
%  - stroke_selector (how are sequential strikes chosen from the bellset
%  data)
%
% If strike_data is not provided, 'perfect' ringing is generated with a
% handstroke gap of one bell time and 'sequential' as the method of stroke
% data selection
function genringing( bellset, rows, outputs, strike_data, peal_time, start_rounds, end_rounds)

% Provide defaults for variables which may not have been provided
if ( ~exist('start_rounds', 'var'))
    start_rounds = [];
end
if ( ~exist('end_rounds', 'var'))
    end_rounds = [];
end
if ( ~exist('peal_time', 'var'))
    peal_time = [];
end
if ( ~exist('strike_data', 'var'))
    strike_data = [];
end


if ( isempty(start_rounds))
    start_rounds = 4;
end
if ( isempty(end_rounds))
    end_rounds = 4;
end
if ( isempty(peal_time) )
    peal_time = bellset.nominal_peal_time;
end


if isempty(outputs)
    error('genringing: At least one output must be specified')
end
if ischar(outputs)
    % If just one output is required, then we can push it into a cell array
    outputs = { outputs };
end


wave_file = '';
xml_file = '';
lowndes_file = '';

for index = 1:length(outputs)
    output_file = outputs{index};
    if ischar(output_file)
        % Let's deduce the file-type based on extension
        if strcmpi(output_file(end-3:end), '.wav')
            wave_file = output_file;
        end
        if strcmpi(output_file(end-3:end), '.xml')
            xml_file = output_file;
        end
        if strcmpi(output_file(end-3:end), '.txt')
            lowndes_file = output_file;
        end
    end
end


% First thing we're going to do is to check that the rows are
% 'sensible' - that is that each bell strikes once only per row
% The number of bells returned is that validated number of
% bells in the touch - this function may fail with an error
number_of_bells = checkNumberOfBells( rows );

% If we don't have any striking data, then let's provide a
% fairly bland default
if ( isempty( strike_data ) )
    strike_data = getdefaultstrikedata(number_of_bells);
end

% We're going to start by sticking on some rounds pre and post the provided touch
rows = [ ones(start_rounds,1) * (1:number_of_bells); rows; ones(end_rounds,1) * (1:number_of_bells) ];


% Next is to generate the audio given these settings
[audio_data, strikes] = genAudioData( number_of_bells, bellset, rows, peal_time, strike_data);
% audio_data is the output wave audio and strikes are the supposed strike positions

% If we're generating lowndes, now is the time to do it!
% Strikes are assumed to be already sorted by time at this point
if ~isempty(lowndes_file)
    % Write the Lowndes
    disp( ['Writing Lowndes: ' lowndes_file] );
    writeLowndesFile( lowndes_file, strikes);
end

% If we're generating XML data output, now is the time to do it!
% Strikes are assumed to be already sorted by time at this point
if ~isempty(xml_file)
    % Write the XML out
    disp( ['Skipping XML gen: ' xml_file] );
    %writeLowndesFile( xml_file, strikes);
end

if ~isempty( wave_file )
    % Write the wave audio
    disp( ['Writing WAV output: ' wave_file] );
    audiowrite( wave_file, audio_data, bellset.fs); 
end

% This function converts rows into audio data given the selected
% strike_data and bellset
function [audio, output_strike_stats] = genAudioData( number_of_bells, bellset, rows, peal_time, strike_data)

% How much silence (in seconds) do we want at the start and end of the
% touch?
presilence = 2;
postsilence = 2;

% How many row pairs are there (i.e. a handstroke and backstroke)
rowpairs = round(size(rows,1)/2);
% This is how long each rowpair should last, based on the peal speed
rowpair_time = 2 * peal_time / 5040;

fs = bellset.fs;
postsilence_samples = round(fs*postsilence);

% The total length of the touch is expected to be the length of the
% pre-silence, the length of the piece plus a bit of silence after
% This is only an estimte to pre-allocate an array of *about* the right
% size - certain factors (such as considerable hum on the training sample)
% will cause the actual length to be longer than this, but that is taken
% care of later!
total_length = presilence + rowpair_time*size(rows,1)/2 + postsilence;
audio = zeros( round(total_length * fs), bellset.channels);

% Divide the rowpair up into 2*n + handstroke gap slots
total_slots_per_rowpair = 2*number_of_bells + strike_data.handstroke_gap;
handstroke_gap = rowpair_time*(strike_data.handstroke_gap/total_slots_per_rowpair);
bell_gap = rowpair_time/total_slots_per_rowpair;

% These are blank variables to hold the state of the strike and audio
% generators (just in case their variability models require persistant
% storage
strike_offset_internals = [];
audio_data_internals = [];

% Also initialise a blank array to contain strike information (time / bell
% / handstroke)
output_strike_stats(number_of_bells*size(rows,1)).ideal = NaN;
strikeIndex = 1;

% All the preamble is over - let's get on with writing the rows (a pair at
% a time)
for writeRows = 1:2:size(rows,1)
    % bell_order is a list of the order the bells should strike in for this
    % row. That can be subsequently altered by extreme offsets in the
    % striking data
   bell_order = rows(writeRows, :);
   
   % The first row of a pair is always assumed to be a handstroke, which
   % we'll signify with a '1'
   is_handstroke = ones(1, number_of_bells);
   if ((writeRows+1)<=size(rows,1))
       % If there is another row, we'll add it on as the backstroke -
       % signified by having elements of is_handstroke == 0
       bell_order = [bell_order rows(writeRows+1,:)];
       is_handstroke = [is_handstroke zeros(1, number_of_bells) ];
   end
    
   % This equation gives the start time of the row pair in seconds.  Note
   % that this is the time of the first strike - i.e. after the handstroke
   % gap has passed
   start_row_pair = presilence + ((writeRows-1)/2)*rowpair_time + handstroke_gap;   
   for write_bells = 1:length(bell_order)
       % Set a couple of convenience variables
       thisBell = bell_order(write_bells);
       handstroke = is_handstroke(write_bells);
       
       % Get a strike offset (i.e. combination of average and standard
       % deviation)
       [strike_offset, strike_offset_internals] = getStrikeOffset( thisBell, handstroke, bell_gap, strike_data, strike_offset_internals);
       
       % Get the actual audio data for the bell note which about to sounded
       [bell_audio_data, audio_offset_samples, audio_data_internals] = getAudioData( thisBell, handstroke, bellset, strike_data, audio_data_internals);
       
       % Sum up all of the data to get the strike point - the start of the
       % strikes, the expected gap to this bell plus the strike offset
       % which has been determined above
       ideal_position = start_row_pair + (write_bells-1)*bell_gap;
       strike_position = ideal_position + strike_offset;
       
       % Convert all of this into a sample position to start writing at
       % taking into account any offset that was present in the original
       % audio data
       strike_sample = round(strike_position * fs + audio_offset_samples);
       
       % If the strike is before the beginning of the file, clip it into
       % the file
       if (strike_sample<1)
           strike_sample=1;
           warning('Attempting to write audio before start of file')
       end
       
       
       last_write_loc = strike_sample + size(bell_audio_data,1);
       % Check that the last location to be writte is still within the file
       % If not, then make the audio longer to accommodate
       if ( (size(audio,1)-postsilence_samples) < last_write_loc)
           audio(last_write_loc+postsilence_samples, :) = 0;
       end
       
       audio_indexer = (1:size(bell_audio_data,1))-1;
       
       % Add the audio strike into the output
       audio( strike_sample + audio_indexer, :) = audio( strike_sample + audio_indexer, :) + bell_audio_data;
       
       % Also record this strike into the strike index
       output_strike_stats( strikeIndex ).actual_time = strike_sample/fs;
       output_strike_stats( strikeIndex ).ideal_time = ideal_position + audio_offset_samples/fs;
       output_strike_stats( strikeIndex).bell = thisBell;
       output_strike_stats( strikeIndex).handstroke = handstroke;
       strikeIndex = strikeIndex+1;
   end
end

output_strike_stats = nestedSortStruct( output_strike_stats, 'actual_time' );



% This function returns an offset to a given strike - that is for a given
% bell at a handstroke or backstroke row, determine strike offset given the
% current settings
%  thisBell is the number of the bell which is about to strike
%  handstroke is a boolean (0 or 1) indicating whether this is a handstroke
%  or not
%  bell_gap is the current nominal gap between strikes
%  strike_data is the current preprepared structure giving details of the
%  striking information
%  strike_offset_internals is a structure (initially empty) which
%  algorithms can use to store persistent information
function [strike_offset, strike_offset_internals] = getStrikeOffset( thisBell, handstroke, bell_gap, strike_data, strike_offset_internals)

% The default is zero offset
strike_offset = 0;


% The 'normal' model means that errors are drawn from a normal distribution
if (strcmpi(strike_data.error_distribution, 'normal'))
    if (handstroke)        
        thisError = randn * strike_data.bell(thisBell).stdev.hand;
    else
        thisError = randn * strike_data.bell(thisBell).stdev.back;
    end
elseif (strcmpi(strike_data.error_distribution, 'uniform'))
    if (handstroke)        
        thisError = sqrt(12) * (rand-0.5) * strike_data.bell(thisBell).stdev.hand;
    else
        thisError = sqrt(12) * (rand-0.5) * strike_data.bell(thisBell).stdev.back;
    end
else
    error(['Unrecognised error distribution model : ' strike_data.error_distribution]);
end

if (strcmpi(strike_data.error_scale, 'ms'))
    strike_offset = strike_offset + (1e-3 * thisError);
elseif (strcmpi(strike_data.error_scale, 'bell'))
    strike_offset = strike_offset + (bell_gap * thisError);
else
    error(['Unrecognised error scale : ' strike_data.error_scale]); 
end


if (handstroke)
    thisOffset = strike_data.bell(thisBell).offset.hand;
else
    thisOffset = strike_data.bell(thisBell).offset.back;
end
    
if (strcmpi(strike_data.offset_scale, 'ms'))
    strike_offset = strike_offset + (1e-3 * thisOffset);
elseif (strcmpi(strike_data.offset_scale, 'bell'))
    strike_offset = strike_offset + (bell_gap * thisOffset);
else
    error(['Unrecognised offset scale : ' strike_data.offset_scale]); 
end

    
% This function returns the audio data for a given strike
% thisBell is the bell number which is about to strike
%  handstroke is a boolean (0 or 1) indicating whether this is a handstroke
%  or not
%  bellset is the structure containing the bell samples
%  strike_data contains data about the synthesis techniques
%  audio_data_internals is a structure (initially empty) which
%  algorithms can use to store persistent information
function [bell_audio_data, audio_offset_samples, audio_data_internals] = getAudioData( thisBell, handstroke, bellset, strike_data, audio_data_internals)

% The 'sequential' strike selector literally just cycles through candidate
% strikes of the handstroke and backstroke in order
if (strcmpi(strike_data.stroke_selector, 'sequential'))
    
    % This algorithm requires persistant information
    % If we find our data store empty, then we'll initialise it to say
    % we're taking our first sample from each available bin
    if isempty(audio_data_internals)
        audio_data_internals.hand = ones( 1, length(bellset.bells));
        audio_data_internals.back = ones( 1, length(bellset.bells));
    end
    
    if handstroke
        selectedStrike = bellset.bells(thisBell).handstroke( audio_data_internals.hand(thisBell) );
        audio_data_internals.hand(thisBell) = mod( audio_data_internals.hand(thisBell), length( bellset.bells(thisBell).handstroke ) ) + 1;
    else
        selectedStrike = bellset.bells(thisBell).backstroke( audio_data_internals.back(thisBell) );
        audio_data_internals.back(thisBell) = mod( audio_data_internals.back(thisBell), length( bellset.bells(thisBell).backstroke ) ) + 1;
    end
elseif (strcmpi(strike_data.stroke_selector, 'random'))    
    % Random just selects an audio sample at random for the chosen bell
    if handstroke
        selectedStrike = bellset.bells(thisBell).handstroke( randi( [1, length( bellset.bells(thisBell).handstroke)] ) );
    else
        selectedStrike = bellset.bells(thisBell).backstroke( randi( [1, length( bellset.bells(thisBell).backstroke)] ) );
    end
else
    error(['Unrecognised audio selector technique: ' strike_data.stroke_selector]);
end
bell_audio_data = selectedStrike.audio;
audio_offset_samples = selectedStrike.offset;


% Returns the number of bells in the touch
% This function verifies that each bell appears once and only once in each
% row
function bell_count = checkNumberOfBells( rows )

rounds = 1:size(rows,2);

for checkRows = 1:size(rows,1)
    if ~all( sort( rows(checkRows, :)) == rounds )
        error( 'Row %d seems a bit strange: %s\n', checkRows, mat2str(rows(checkRows,:) ) );
    end
end

bell_count = size(rows,2);


function writeLowndesFile( lowndes_file, strikes)

lowndes_fid = fopen(lowndes_file, 'w');
if (lowndes_fid>=0)
    % Strike data is rows of:
    %   Time Bell Hand/back
    firstStrike = strikes(1).actual_time;

    % Write a header - just copied from Hawkear output
    fprintf(lowndes_fid, '#. Lowndes: Version 2 (support comments in the file)\n');
    fprintf(lowndes_fid, '#. Creator: genRinging Version 0.1\n');
    fprintf(lowndes_fid, '#. TranscriptionDate: %s\n', datestr(now, 'yyyy-mm-dd--HH-MM'));
    fprintf(lowndes_fid, '#. FirstBlowMs: %d\n', round(1000*firstStrike));

    % Write out the strikes one by one
    for writeStrikes = 1:size(strikes,1)
        if strikes(writeStrikes).bell>0
            strikeTime = strikes(writeStrikes).actual_strike - firstStrike;
            if (strikes(writeStrikes).handstroke)
                hbIdent = 'H';
            else
                hbIdent = 'B';
            end
            bellIds = { '1', '2', '3', '4', '5', '6', '7', '8', '9', 'O', 'E', 'T' };
            fprintf(lowndes_fid, '%s %s 0X%04x\n', hbIdent, bellIds{ strikes(writeStrikes).bell }, mod( round(1000*strikeTime), 65536) );
        end
    end
else
    warning('genringing: could not create Lowndes file %s', lowndes_file)
end
fclose(lowndes_fid);

function [sortedStruct, index] = nestedSortStruct(aStruct, fieldNamesCell, directions)
% [sortedStruct index] = nestedSortStruct(aStruct, fieldNamesCell, directions)
% nestedSortStruct returns a nested sort of a (one-dimensional) struct array
% (aStruct), and can also return an index vector. The fields by which to sort are
% specified in a cell array of strings fieldNamesCell. Fields must be single numbers or
% logicals, or chars (usually simple strings).
%
% fieldNamesCell can also be a simple string of one fieldname, in which case
% nestedSortStruct will simply call sortStruct. This will be faster than putting the
% single fieldname in a cell array.
%
% directions is an optional argument to specify whether the struct array should be sorted
% in ascending or descending order for the fields. By default, the struct array will be
% sorted in ascending order for each field. If supplied, directions must be
%       1) a single 1 to sort in ascending order for all fields, or
%       2) a single -1 to sort in descending order for all fields, or
%       3) a vector of 1's and -1's, the same length as fieldNamesCell, where the struct
%          array will be sorted in the order specified by directions(ii) for
%          fieldNamesCell(ii).
%
% nestedSortStruct basically converts the struct array to a cell array, then converts
% relevants parts of the cell array to a matrix, on which sortrows is run.
%
% nestedSortStruct will usually be faster than nestedSortStruct2. For nestedSortStruct,
% the speed of sorting is mostly independent of the order of the fieldnames in fieldNamesCell.
%
% For nestedSortStruct2, the order of the fields in fieldNamesCell affects the speed. The
% sooner a field for which most entries in the struct array have unique values will be
% used to sort the struct array (i.e., the earlier that field's location in
% fieldNamesCell), the faster nestedSortStruct2 will be. If a field with mostly unique
% entries is the first field by which the struct array will be sorted, nestedSortStruct2
% could be faster than nestedSortStruct.

% check struct
if ~isstruct(aStruct)
    error('first input supplied is not a struct.')
end % if

if sum(size(aStruct)>1)>1 % if more than one non-singleton dimension
    error('I don''t want to sort your multidimensional struct array.')
end % if

% check fieldnames
if ~iscell(fieldNamesCell)
    if isfield(aStruct, fieldNamesCell) % if fieldNamesCell is a simple string of a valid fieldname
        [sortedStruct, index] = sortStruct(aStruct, fieldNamesCell);
        return
    else
        error('second input supplied is not a cell array or simple string of a fieldname.')
    end % if isfield
end % if ~iscell

if ~isfield(aStruct, fieldNamesCell)
    for ii=find(~isfield(aStruct, fieldNamesCell))
        fprintf('%s is not a fieldname in the struct.\n', fieldNamesCell{ii})
    end % for
    error('at least one entry in fieldNamesCell is not a fieldname in the struct.')
end % if

% check classes of fieldnames
fieldFlag = 0;
for ii=1:length(fieldNamesCell)
    fieldEntry = aStruct(1).(fieldNamesCell{ii});
    if ~( ((isnumeric(fieldEntry) || islogical(fieldEntry)) && numel(fieldEntry)==1) || ischar(fieldEntry) )
        fprintf('%s is not a valid fieldname by which to sort.\n', fieldNamesCell{ii})
        fieldFlag = 1;
    end % if
end % for ii

if fieldFlag
    error('at least one fieldname is not a valid one by which to sort.')
end

% check directions, create if necessary (1 for ascending, -1 for descending)
if nargin < 3 % if directions doesn't exist
    directions = ones(1, length(fieldNamesCell));
else % check directions if it does exist
    if ~(isnumeric(directions) && all(ismember(directions, [-1 1])))
        error('directions, if given, must be a single number or a vector with 1 (ascending) and -1 (descending).')
    end % if ~(...
    
    if numel(directions)==1
        directions = directions * ones(1, length(fieldNamesCell)); % create vector from single element
    elseif length(fieldNamesCell)~=length(directions)
        error('fieldNamesCell and directions vector are different lengths.')
    end % if numel...
end % if exist...

% fieldNamesIdx is a vector of the indices of the fields by which to sort
[~, fieldNamesIdx] = ismember(fieldNamesCell, fieldnames(aStruct));

% convert the struct to a cell, squeeze makes sure both row and column arrays are sorted properly, transpose for sortrows
aCell = squeeze(struct2cell(aStruct))';

% sortrows of aCell, using indices from fieldNamesIdx and directions
[~, index] = sortrows(aCell, fieldNamesIdx .* directions);

sortedStruct = aStruct(index); % apply the index to the struct array

function [sortedStruct, index] = sortStruct(aStruct, fieldName, direction)
% [sortedStruct index] = sortStruct(aStruct, fieldName, direction)
% sortStruct returns a sorted struct array, and can also return an index vector. The
% (one-dimensional) struct array (aStruct) is sorted based on the field specified by the
% string fieldName. The field must a single number or logical, or a char array (usually a
% simple string).
%
% direction is an optional argument to specify whether the struct array should be sorted
% in ascending or descending order. By default, the array will be sorted in ascending
% order. If supplied, direction must equal 1 to sort in ascending order or -1 to sort in
% descending order.

% check inputs
if ~isstruct(aStruct)
    error('first input supplied is not a struct.')
end % if

if sum(size(aStruct)>1)>1 % if more than one non-singleton dimension
    error('I don''t want to sort your multidimensional struct array.')
end % if

if ~ischar(fieldName) || ~isfield(aStruct, fieldName)
    error('second input is not a valid fieldname.')
end % if

if nargin < 3
    direction = 1;
elseif ~isnumeric(direction) || numel(direction)>1 || ~ismember(direction, [-1 1])
    error('direction must equal 1 for ascending order or -1 for descending order.')
end % if

% figure out the field's class, and find the sorted index vector
fieldEntry = aStruct(1).(fieldName);

if (isnumeric(fieldEntry) || islogical(fieldEntry)) && numel(fieldEntry) == 1 % if the field is a single number
    [~, index] = sort([aStruct.(fieldName)]);
elseif ischar(fieldEntry) % if the field is char
    [~, index] = sort({aStruct.(fieldName)});
else
    error('%s is not an appropriate field by which to sort.', fieldName)
end % if ~isempty

% apply the index to the struct array
if direction == 1 % ascending sort
    sortedStruct = aStruct(index);
else % descending sort
    sortedStruct = aStruct(index(end:-1:1));
end
