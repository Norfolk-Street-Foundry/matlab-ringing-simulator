% FUNCTION genringing
%  genringing( bellset, rows, output_file, strike_data, peal_time, lowndes_output, start_rounds, end_rounds)
%
% bellset is a structure containing the following elements:
%  - bells (1xN structure)
%    - handstroke (cell array of wav data, representing different handstrokes of this bell)
%    - backstroke (... backstrokes)
%  - fs (sampling frequency of the WAV data)
%  - channel (number of channels in the WAV data, typically one or two)
%  - nominal_peal_time (used if no other speed is provided)
%
% rows is a matrix describing the changes to be rung - usually generated by
% rows_from_gsiril
%
% output_file is the name of a WAV file to store the output data
%
% start_rounds / end_rounds are the number of rounds starting and ending
% the touch. Defaults to 2 if not specified
%
% peal_time - override the tower nominal peal time
%
% lowndes_output - if true, then output a 'lowndes' format file suitable
% for analysis in CAS etc. Default is true.
%
% strike_data is a structure containing the following elements:
%  - handstroke_gap (in terms inter-bell gap - that is, normally set to 1)
%  - bell (1xN structure)
%   - offset
%    - hand (handstroke offset for this bell)
%    - back (backstroke offset for this bell)
%   - stdev
%    - hand (handstroke deviation for this bell)
%    - back (backstroke deviation for this bell)
%  - error_scale (how are the stdevs interpreted - valid settings are either 'ms' or 'bell')
%  - error_distribution (formation of  - valid settings are either 'ms' or 'bell')
%  - offset_scale (how are the offsets interpreted - valid settings are either 'ms' or 'bell')
%  - stroke_selector (how are sequential strikes chosen from the bellset
%  data)
%
% If strike_data is not provided, 'perfect' ringing is generated with a
% handstroke gap of one bell time and 'sequential' as the method of stroke
% data selection
function genringing( bellset, rows, output_file, strike_data, peal_time, lowndes_output, start_rounds, end_rounds)

% Provide defaults for variables which may not have been provided
if ( ~exist('start_rounds', 'var'))
    start_rounds = [];
end
if ( ~exist('end_rounds', 'var'))
    end_rounds = [];
end
if ( ~exist('peal_time', 'var'))
    peal_time = [];
end
if ( ~exist('lowndes_output', 'var'))
    lowndes_output = [];
end
if ( ~exist('strike_data', 'var'))
    strike_data = [];
end


if ( isempty(start_rounds))
    start_rounds = 4;
end
if ( isempty(end_rounds))
    end_rounds = 4;
end
if ( isempty(peal_time) )
    peal_time = bellset.nominal_peal_time;
end
if ( isempty(lowndes_output))
    lowndes_output = 1;
end


% First thing we're going to do is to check that the rows are
% 'sensible' - that is that each bell strikes once only per row
% The number of bells returned is that validated number of
% bells in the touch - this function may fail with an error
number_of_bells = checkNumberOfBells( rows );

% If we don't have any striking data, then let's provide a
% fairly bland default
if ( isempty( strike_data ) )
    strike_data = getdefaultstrikedata(number_of_bells);
end

% We're going to start by sticking on some rounds pre and post the provided touch
rows = [ ones(start_rounds,1) * (1:number_of_bells); rows; ones(end_rounds,1) * (1:number_of_bells) ];


% Next is to generate the audio given these settings
[audio_data, strikes] = genAudioData( number_of_bells, bellset, rows, peal_time, strike_data);
% audio_data is the output wave audio and strikes are the supposed strike positions

% If we're generating lowndes, now is the time to do it!
% Strikes are assumed to be already sorted by time at this point
if (lowndes_output)
    [output_path, output_base] = fileparts( output_file );
    lowndes_file = fullfile( output_path, [output_base '.txt']);
    lowndes_fid = fopen(lowndes_file, 'w');
    if (lowndes_fid>=0)
        % Strike data is rows of:
        %   Time Bell Hand/back
        firstStrike = strikes(1,1);
        
        % Write a header - just copied from Hawkear output
        fprintf(lowndes_fid, '#. Lowndes: Version 2 (support comments in the file)\n');
        fprintf(lowndes_fid, '#. Creator: genRinging Version 0.1\n');
        fprintf(lowndes_fid, '#. TranscriptionDate: %s\n', datestr(now, 'yyyy-mm-dd--HH-MM'));
        fprintf(lowndes_fid, '#. FirstBlowMs: %d\n', round(1000*firstStrike));
        
        % Write out the strikes one by one
        for writeStrikes = 1:size(strikes,1)
            if strikes(writeStrikes,2)>0
                strikeTime = strikes(writeStrikes,1) - firstStrike;
                if (strikes(writeStrikes, 3) == 1)
                    hbIdent = 'H';
                else
                    hbIdent = 'B';
                end
                bellIds = { '1', '2', '3', '4', '5', '6', '7', '8', '9', 'O', 'E', 'T' };
                fprintf(lowndes_fid, '%s %s 0X%04x\n', hbIdent, bellIds{ strikes(writeStrikes, 2) }, mod( round(1000*strikeTime), 65536) );
            end
        end
    end
    fclose(lowndes_fid);
end

% Write the wave audio
disp( ['Writing ' output_file] );
audiowrite( output_file, audio_data, bellset.fs);

% This function converts rows into audio data given the selected
% strike_data and bellset
function [audio, strikes] = genAudioData( number_of_bells, bellset, rows, peal_time, strike_data)

% How much silence (in seconds) do we want at the start and end of the
% touch?
presilence = 2;
postsilence = 2;

% How many row pairs are there (i.e. a handstroke and backstroke)
rowpairs = round(size(rows,1)/2);
% This is how long each rowpair should last, based on the peal speed
rowpair_time = 2 * peal_time / 5040;

fs = bellset.fs;
postsilence_samples = round(fs*postsilence);

% The total length of the touch is expected to be the length of the
% pre-silence, the length of the piece plus a bit of silence after
% This is only an estimte to pre-allocate an array of *about* the right
% size - certain factors (such as considerable hum on the training sample)
% will cause the actual length to be longer than this, but that is taken
% care of later!
total_length = presilence + rowpair_time*size(rows,1)/2 + postsilence;
audio = zeros( round(total_length * fs), bellset.channels);

% Divide the rowpair up into 2*n + handstroke gap slots
total_slots_per_rowpair = 2*number_of_bells + strike_data.handstroke_gap;
handstroke_gap = rowpair_time*(strike_data.handstroke_gap/total_slots_per_rowpair);
bell_gap = rowpair_time/total_slots_per_rowpair;

% These are blank variables to hold the state of the strike and audio
% generators (just in case their variability models require persistant
% storage
strike_offset_internals = [];
audio_data_internals = [];

% Also initialise a blank array to contain strike information (time / bell
% / handstroke)
strikes = zeros( number_of_bells*size(rows,1), 3);
strikeIndex = 1;

% All the preamble is over - let's get on with writing the rows (a pair at
% a time)
for writeRows = 1:2:size(rows,1)
    % bell_order is a list of the order the bells should strike in for this
    % row. That can be subsequently altered by extreme offsets in the
    % striking data
   bell_order = rows(writeRows, :);
   
   % The first row of a pair is always assumed to be a handstroke, which
   % we'll signify with a '1'
   is_handstroke = ones(1, number_of_bells);
   if ((writeRows+1)<=size(rows,1))
       % If there is another row, we'll add it on as the backstroke -
       % signified by having elements of is_handstroke == 0
       bell_order = [bell_order rows(writeRows+1,:)];
       is_handstroke = [is_handstroke zeros(1, number_of_bells) ];
   end
    
   % This equation gives the start time of the row pair in seconds.  Note
   % that this is the time of the first strike - i.e. after the handstroke
   % gap has passed
   start_row_pair = presilence + ((writeRows-1)/2)*rowpair_time + handstroke_gap;   
   for write_bells = 1:length(bell_order)
       % Set a couple of convenience variables
       thisBell = bell_order(write_bells);
       handstroke = is_handstroke(write_bells);
       
       % Get a strike offset (i.e. combination of average and standard
       % deviation)
       [strike_offset, strike_offset_internals] = getStrikeOffset( thisBell, handstroke, bell_gap, strike_data, strike_offset_internals);
       
       % Get the actual audio data for the bell note which about to sounded
       [bell_audio_data, audio_offset_samples, audio_data_internals] = getAudioData( thisBell, handstroke, bellset, strike_data, audio_data_internals);
       
       % Sum up all of the data to get the strike point - the start of the
       % strikes, the expected gap to this bell plus the strike offset
       % which has been determined above
       strike_position = start_row_pair + (write_bells-1)*bell_gap + strike_offset;
       
       % Convert all of this into a sample position to start writing at
       % taking into account any offset that was present in the original
       % audio data
       strike_sample = round(strike_position * fs + audio_offset_samples);
       
       % If the strike is before the beginning of the file, clip it into
       % the file
       if (strike_sample<1)
           strike_sample=1;
           warning('Attempting to write audio before start of file')
       end
       
       
       last_write_loc = strike_sample + size(bell_audio_data,1);
       % Check that the last location to be writte is still within the file
       % If not, then make the audio longer to accommodate
       if ( (size(audio,1)-postsilence_samples) < last_write_loc)
           audio(last_write_loc+postsilence_samples, :) = 0;
       end
       
       audio_indexer = (1:size(bell_audio_data,1))-1;
       
       % Add the audio strike into the output
       audio( strike_sample + audio_indexer, :) = audio( strike_sample + audio_indexer, :) + bell_audio_data;
       
       % Also record this strike into the strike index
       strikes( strikeIndex, 1) = strike_sample/fs;
       strikes( strikeIndex, 2) = thisBell;
       strikes( strikeIndex, 3) = handstroke;
       strikeIndex = strikeIndex+1;
   end
end

strikes = sortrows(strikes, 1);



% This function returns an offset to a given strike - that is for a given
% bell at a handstroke or backstroke row, determine strike offset given the
% current settings
%  thisBell is the number of the bell which is about to strike
%  handstroke is a boolean (0 or 1) indicating whether this is a handstroke
%  or not
%  bell_gap is the current nominal gap between strikes
%  strike_data is the current preprepared structure giving details of the
%  striking information
%  strike_offset_internals is a structure (initially empty) which
%  algorithms can use to store persistent information
function [strike_offset, strike_offset_internals] = getStrikeOffset( thisBell, handstroke, bell_gap, strike_data, strike_offset_internals)

% The default is zero offset
strike_offset = 0;


% The 'normal' model means that errors are drawn from a normal distribution
if (strcmpi(strike_data.error_distribution, 'normal'))
    if (handstroke)        
        thisError = randn * strike_data.bell(thisBell).stdev.hand;
    else
        thisError = randn * strike_data.bell(thisBell).stdev.back;
    end
elseif (strcmpi(strike_data.error_distribution, 'uniform'))
    if (handstroke)        
        thisError = sqrt(12) * (rand-0.5) * strike_data.bell(thisBell).stdev.hand;
    else
        thisError = sqrt(12) * (rand-0.5) * strike_data.bell(thisBell).stdev.back;
    end
else
    error(['Unrecognised error distribution model : ' strike_data.error_distribution]);
end

if (strcmpi(strike_data.error_scale, 'ms'))
    strike_offset = strike_offset + (1e-3 * thisError);
elseif (strcmpi(strike_data.error_scale, 'bell'))
    strike_offset = strike_offset + (bell_gap * thisError);
else
    error(['Unrecognised error scale : ' strike_data.error_scale]); 
end


if (handstroke)
    thisOffset = strike_data.bell(thisBell).offset.hand;
else
    thisOffset = strike_data.bell(thisBell).offset.back;
end
    
if (strcmpi(strike_data.offset_scale, 'ms'))
    strike_offset = strike_offset + (1e-3 * thisOffset);
elseif (strcmpi(strike_data.offset_scale, 'bell'))
    strike_offset = strike_offset + (bell_gap * thisOffset);
else
    error(['Unrecognised offset scale : ' strike_data.offset_scale]); 
end

    
% This function returns the audio data for a given strike
% thisBell is the bell number which is about to strike
%  handstroke is a boolean (0 or 1) indicating whether this is a handstroke
%  or not
%  bellset is the structure containing the bell samples
%  strike_data contains data about the synthesis techniques
%  audio_data_internals is a structure (initially empty) which
%  algorithms can use to store persistent information
function [bell_audio_data, audio_offset_samples, audio_data_internals] = getAudioData( thisBell, handstroke, bellset, strike_data, audio_data_internals)

% The 'sequential' strike selector literally just cycles through candidate
% strikes of the handstroke and backstroke in order
if (strcmpi(strike_data.stroke_selector, 'sequential'))
    
    % This algorithm requires persistant information
    % If we find our data store empty, then we'll initialise it to say
    % we're taking our first sample from each available bin
    if isempty(audio_data_internals)
        audio_data_internals.hand = ones( 1, length(bellset.bells));
        audio_data_internals.back = ones( 1, length(bellset.bells));
    end
    
    if handstroke
        selectedStrike = bellset.bells(thisBell).handstroke( audio_data_internals.hand(thisBell) );
        audio_data_internals.hand(thisBell) = mod( audio_data_internals.hand(thisBell), length( bellset.bells(thisBell).handstroke ) ) + 1;
    else
        selectedStrike = bellset.bells(thisBell).backstroke( audio_data_internals.back(thisBell) );
        audio_data_internals.back(thisBell) = mod( audio_data_internals.back(thisBell), length( bellset.bells(thisBell).backstroke ) ) + 1;
    end
elseif (strcmpi(strike_data.stroke_selector, 'random'))    
    % Random just selects an audio sample at random for the chosen bell
    if handstroke
        selectedStrike = bellset.bells(thisBell).handstroke( randi( [1, length( bellset.bells(thisBell).handstroke)] ) );
    else
        selectedStrike = bellset.bells(thisBell).backstroke( randi( [1, length( bellset.bells(thisBell).backstroke)] ) );
    end
else
    error(['Unrecognised audio selector technique: ' strike_data.stroke_selector]);
end
bell_audio_data = selectedStrike.audio;
audio_offset_samples = selectedStrike.offset;


% Returns the number of bells in the touch
% This function verifies that each bell appears once and only once in each
% row
function bell_count = checkNumberOfBells( rows )

rounds = 1:size(rows,2);

for checkRows = 1:size(rows,1)
    if ~all( sort( rows(checkRows, :)) == rounds )
        error( sprintf('Row %d seems a bit strange: %s\n', checkRows, mat2str(rows(checkRows,:)) ) );
    end
end

bell_count = size(rows,2);

